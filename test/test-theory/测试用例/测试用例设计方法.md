# 测试用例设计方法
## 等价类划分
### 定义
等价类划分是将程序的输入域或输出域的不同区间划分为不同的数据类，以便导出测试用例。每个等价类所揭示的程序错误都是等价的，要求此方法的测试用例能各自发现一类错误，从而减少必须开发的测试用例数 。

### 分类
等价类主要分为两种：
* 有效等价类：对系统来说是有效的输入，利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。
* 无效等价类：所有其它可能存在的情况，与有效等价类的定义恰巧相反。

### 用例设计步骤
1. 划分等价类
2. 为每一个有效等价类和无效等价类规定一个唯一的编号
3. 设计一个测试用例，使其尽可能多地覆盖尚未覆盖的有效等价类， 重复这一步直到所有有效等价类均被测试用例所覆盖
4. 设计一个测试用例，使其只覆盖一个无效等价类，重复这一步，直到所有无效等价类均被覆盖

**使用下面的表格有利于确定测试用例**
| 条件   | 有效等价类       | 编号   | 无效等价类 | 编号   |
| ------ | ---------------- | ------ | ---------- | ------ |
| &nbsp; | &nbsp;    &nbsp; | &nbsp; | &nbsp;     | &nbsp; |

### 举例
#### 功能描述
NextDate（年，月，日）是三个变量的函数。函数返回输入日期的下一个日期。变量年份，月份，日期都是整数值，且满足下面的条件： 1900<=年<=2060 ,1<=月<=12, 1<=日<=31

#### 参考答案
**等价类划分**

| 条件 | 有效等价类   | 编号 | 无效等价类 | 编号 |
| ---- | ------------ | ---- | ---------- | ---- |
| 年   | 闰年         | 1    | 年<=1900   | 11   |
|      | 平年         | 2    | 年>=2060   | 12   |
| 月   | 1,3,5,7,8,10 | 3    | 月<1       | 13   |
|      | 4,6,9,11     | 4    | 月>12      | 14   |
|      | 2月          | 5    |            |      |
|      | 12月         | 6    |            |      |
| 日   | [1,28]       | 7    | 日<1       | 15   |
|      | 29           | 8    | 日>31      | 16   |
|      | 30           | 9    |            |      |
|      | 31           | 10   |            |      |

**测试用例**
1. 覆盖等价类2,3,10:  测试输入=(2001,7,31), 预期结果=(2001,8,1)
2. 覆盖等价类2,4,9: 测试输入=(2006,4,30), 预期结果=(2006,5,1)
3. 覆盖等价类1,5,8:  测试输入=(2000,2,29), 预期结果=(2000,3,1)
4. 覆盖等价类2,6,7: 测试输入=(2001,12,15),预期结果=(2001,12,16)
5. 覆盖等价类11,3,7: 测试输入=(1830,3,19), 预期结果=“输入错误!”
6. 覆盖等价类12,3,7: 测试输入=(3000,3,19), 预期结果=“输入错误!”
7. 覆盖等价类1,13,7: 测试输入=(2004,-2,10),预期结果=“输入错误!”
8. 覆盖等价类1,14,7: 测试输入=(2004,15,10),预期结果=输入错误!”
9. 覆盖等价类1,3,15: 测试输入=(2004,8,-2), 预期结果=“输入错误!”
10. 覆盖等价类1,3,16: 测试输入=(2004,8,38),预期结果=“输入错误!”

#### 说明
测试用例涵盖了大部分需测试的要点，但仍有些遗漏，例如年底、平年的二月等。

如何再次提高测试用例质量呢？  
1. 在实际测试时，可以考虑增加一些测试用例来补充，或者通过其他测试用例设计方法来补充等价类划分无法覆盖到的测试点（实际中会使用错误猜测法）。
2. 根据功能规格说明，选取恰当的测试用例设计方法。Nextdate各个输入变量之间其实并不是完全独立的，在设计测试用例时并没有考虑到这点，可以使用：
   * 各个变量之间进行全组合
   * 判定表
3. 综合运用多种测试用例设计方法，以求得测试质量与成本之间的平衡

## 边界值分析
### 定义
边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。

### 设计思路
1. 如果输入条件定义了数值区间[a,b]，那么测试用例应包括a、b、稍微比a大、稍微比b大、稍微比a小和稍微比b小等几种情况。
    > **举例**
    程序的规格说明中规定："重量在10公斤至50公斤范围内的包裹，其邮费计算公式为…"。  
    作为测试用例，我们应取10及50，还应取10.01、50.01、9.99及49.99等。
2. 如果输入条件规定了值的个数, 那么最小个数、最大个数、大于和小于最小值、大于和小于最大值都应该被测试。
    > **举例**
    程序的规格说明中规定："邮箱可以存放1~255个邮件"。  
    作为测试用例，测试用例可取1和255，还应取0及256等。
3. 将思路1和思路应用于输出条件，即设计测试用例使输出值达到边界值及其左右的值。
4. 如果程序的规格说明给出的输入域或输出域是有序集合，则应选取集合的第一个元素和最后一个元素作为测试用例。
5. 如果在程序中的数据结构有指定的边界，那么选择这个数据结构边界上的值作为测试用例。
6. 分析规格说明，找出其它可能的边界条件

### 举例
#### 功能描述
某选课系统中规定每门课程的选修人数在[20，60]之间，小于20人不开设该门选修课，大于60人不接受后面的选课要求。  
**输入变量**：选课人数

#### 参考答案
**测试用例**：
选择当选课人数分别为19，20，21, 59，60和61等几个边界点
再加上一个正常值点40

## 错误推断法
### 定义
基于经验和直觉推测程序中所有可能存在的各种错误, 针对这些错误设计相应的测试用例。
### 设计思路
基本思想：列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据他们选择测试用例。
### 举例
#### 功能描述
对一个对数组进行顺序排序
#### 参考答案
**测试用例**：  
1. 输入的数组为空数组；
2. 数组只含有一个元素；
3. 输入数组中所有元素已排好序；
4. 输入数组已按逆序排好；
5. 输入数组中部分或全部元素相同。

## 判定表驱动法
### 定义
判定表是把作为条件的所有输入的各种组合值以及对应输出值都罗列出来而形成的表格。它能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。
### 判定表组成
判定表由四个部分组成，分别是条件桩(condition stub), 条件项(condition entry), 动作桩(action stub)和动作项（action entry）。
1. 条件桩是条件的列表
2. 动作桩是满足条件时系统可能产生的动作的列表
3. 条件项是条件值的组合 
4. 动作项是在条件值组合情况下发生的动作
5. 表中的每一列称为一条规则，规则定义了动作在什么条件下发生

### 分类
* 有限项判定表：每个条件只有两个值,如Y/N, T/F,1/0 等
* 扩展项判定表：条件项的取值有多个（大于2个）

### 判定表的建立步骤
1. 确定规则的个数，假如有n个条件，每个条件有两个取值（0,1）,故有2^n种规则；
2. 列出所有的条件桩和动作桩；
3. 填入条件项；
4. 填入动作项，制定初始判定表；
5. 简化、合并相似规则或相同动作。
  > 简化：就是把有两条或多条具有相同的动作、且其条件项之间存在着极为相似的关系的规则合并。

### 有限项判定表举例
#### 功能描述

打印机是否能打印出来正确的内容，有多个因素影响，包括驱动程序、纸张、墨粉等。（为了简化问题，不考虑中途断电、卡纸等因素的影响）

#### 参考答案
**条件桩**：

1. 驱动程序是否正确?
2. 是否有纸张？
3. 是否有墨粉？

**动作桩**：（动作桩有两种：打印内容和不同的错误提示，并且假定：优先警告缺纸，然后警告没有墨粉，最有警告驱动程序不对。）

1. 打印内容
2. 提示驱动程序不对
3. 提示没有纸张
4. 提示没有墨粉

<center>初始化的判定表</center>

<table style="width:516pt">
    <tbody>
        <tr>
            <td colspan="2">序号</td>
            <td>1</td>
            <td>2</td>
            <td>3</td>
            <td>4</td>
            <td>5</td>
            <td>6</td>
            <td>7</td>
            <td>8</td>
        </tr>
        <tr>
            <td rowspan="3">条件</td>
            <td>驱动程序是否正确？</td>
            <td>Y</td>
            <td>N</td>
            <td>Y</td>
            <td>Y</td>
            <td>N</td>
            <td>N</td>
            <td>Y</td>
            <td>N</td>
        </tr>
        <tr>
            <td>是否有纸张？</td>
            <td>Y</td>
            <td>Y</td>
            <td>N</td>
            <td>Y</td>
            <td>N</td>
            <td>Y</td>
            <td>N</td>
            <td>N</td>
        </tr>
        <tr>
            <td>是否有墨粉？</td>
            <td>Y</td>
            <td>Y</td>
            <td>Y</td>
            <td>N</td>
            <td>Y</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
        </tr>
        <tr>
            <td rowspan="4">动作</td>
            <td>打印内容</td>
            <td>Y</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
        </tr>
        <tr>
            <td>提示驱动程序不对</td>
            <td>N</td>
            <td>Y</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
        </tr>
        <tr>
            <td>提示没有纸张</td>
            <td>N</td>
            <td>N</td>
            <td>Y</td>
            <td>N</td>
            <td>Y</td>
            <td>N</td>
            <td>Y</td>
            <td>Y</td>
        </tr>
        <tr>
            <td>提示没有墨粉</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
            <td>Y</td>
            <td>N</td>
            <td>Y</td>
            <td>N</td>
            <td>N</td>
        </tr>
    </tbody>
</table>

> 注：输入条件项，即上述每个条件的值分别取“是（Y）”和“否（N）”。

<center>优化的判定表</center>
<table style="width:312pt">
    <tbody>
        <tr>
            <td colspan="2">序号</td>
            <td>1</td>
            <td>2</td>
            <td>4/6</td>
            <td>3/5/7/8</td>
        </tr>
        <tr>
            <td rowspan="3">条件</td>
            <td>驱动程序是否正确？</td>
            <td>Y</td>
            <td>N</td>
            <td>Y</td>
            <td>--</td>
        </tr>
        <tr>
            <td>是否有纸张？</td>
            <td>Y</td>
            <td>Y</td>
            <td>Y</td>
            <td>N</td>
        </tr>
        <tr>
            <td>是否有墨粉？</td>
            <td>Y</td>
            <td>Y</td>
            <td>N</td>
            <td>--</td>
        </tr>
        <tr>
            <td rowspan="4">动作</td>
            <td>打印内容</td>
            <td>Y</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
        </tr>
        <tr>
            <td>提示驱动程序不对</td>
            <td>N</td>
            <td>Y</td>
            <td>N</td>
            <td>N</td>
        </tr>
        <tr>
            <td>提示没有纸张</td>
            <td>N</td>
            <td>N</td>
            <td>N</td>
            <td>Y</td>
        </tr>
        <tr>
            <td>提示没有墨粉</td>
            <td>N</td>
            <td>N</td>
            <td>Y</td>
            <td>N</td>
        </tr>
    </tbody>
</table>

> 注：  
* 如果动作结果一样，对于某些因素取“1”或“0”没有影响，即以“—”表示，并合并。
* 优化的判定表就可以设计测试用例，每一列代表一条测试用例。

### 扩展项判断表举例


### 判定表的优/缺点:
**优点**：把复杂的问题按各种可能的情况一一列举，简明而易于理解，也避免遗漏。

**缺点**：
1. 不能表达重复执行的动作，如循环结构；
2. 判定表不能很好的伸缩。如有n个条件的判定表有2<sup>n</sup>个规则。

### 适合使用判定表设计测试用例的条件：
1. 规格说明以判定表形式给出，或很容易转换成判定表的。
2. 条件的排列顺序不会也不影响执行哪些操作。
3. 规则的排列顺序不会也不影响执行哪些操作。
4. 每当某一规则的条件已近满足，并确定要执行的操作后，不必检验别的规则。
5.  如果某一规则得到满足要执行多个操作，这些操作的执行顺序无关紧要。

> 注：对于某些不满足如上条件的判定表，同样也可以应用它来设计测试用例，只不过还要增加其他的测试用例。